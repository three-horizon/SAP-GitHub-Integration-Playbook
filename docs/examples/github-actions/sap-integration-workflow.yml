# SAP-GitHub Integration Workflow
#
# This workflow demonstrates a comprehensive SAP-GitHub integration process:
# 1. Pulls SAP ABAP code using abapGit API
# 2. Validates and tests the code
# 3. Creates transport requests
# 4. Deploys to QAS after approval
# 5. Implements security scanning
# 6. Provides notifications on status
#
# Prerequisites:
# - SAP environment with abapGit installed
# - GitHub repository set up with necessary secrets
# - Azure Key Vault for credential management
# - Sentinel monitoring configured

name: SAP-GitHub Integration Pipeline

# Trigger on pull request or push to main/develop branches
# Can also be manually triggered with specified parameters
on:
  pull_request:
    branches: [ main, develop ]
    paths:
      - 'src/**'
      - 'config/**'
      - '.github/workflows/sap-integration-workflow.yml'
  push:
    branches: [ main, develop ]
    paths:
      - 'src/**'
      - 'config/**'
  workflow_dispatch:
    inputs:
      target_environment:
        description: 'Target SAP Environment'
        required: true
        default: 'DEV'
        type: choice
        options:
          - DEV
          - QAS
          - PRD
      transport_request:
        description: 'Existing transport request number (optional)'
        required: false
        type: string
      skip_tests:
        description: 'Skip unit tests'
        required: false
        default: false
        type: boolean

# Define environment variables used throughout the workflow
env:
  SAP_SERVER_DEV: 'sapdev.example.com'
  SAP_SERVER_QAS: 'sapqas.example.com'
  SAP_SERVER_PRD: 'sapprd.example.com'
  SAP_CLIENT: '100'
  SAP_PACKAGE: 'ZGITHUB_DEMO'
  AZURE_KEYVAULT_NAME: 'sap-github-integration-kv'
  SENTINEL_WORKSPACE_ID: '${{ secrets.SENTINEL_WORKSPACE_ID }}'
  SENTINEL_WORKSPACE_KEY: '${{ secrets.SENTINEL_WORKSPACE_KEY }}'

# Permission settings for GitHub Token
permissions:
  contents: read
  pull-requests: write
  id-token: write # Required for OIDC authentication with Azure

# A workflow run is made up of one or more jobs
jobs:
  # Initial validation job
  validate:
    name: Validate Code & Configuration
    runs-on: ubuntu-latest
    outputs:
      sap_server: ${{ steps.set-environment.outputs.sap_server }}
      environment: ${{ steps.set-environment.outputs.environment }}
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # Fetch all history for proper change detection
      
      - name: Set Environment Variables
        id: set-environment
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            ENVIRONMENT="${{ github.event.inputs.target_environment }}"
          elif [ "${{ github.ref }}" == "refs/heads/main" ]; then
            ENVIRONMENT="QAS"
          else
            ENVIRONMENT="DEV"
          fi
          
          if [ "$ENVIRONMENT" == "DEV" ]; then
            SAP_SERVER="${{ env.SAP_SERVER_DEV }}"
          elif [ "$ENVIRONMENT" == "QAS" ]; then
            SAP_SERVER="${{ env.SAP_SERVER_QAS }}"
          else
            SAP_SERVER="${{ env.SAP_SERVER_PRD }}"
          fi
          
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "sap_server=$SAP_SERVER" >> $GITHUB_OUTPUT
          echo "Selected environment: $ENVIRONMENT, Server: $SAP_SERVER"
      
      - name: Validate ABAP syntax
        run: |
          echo "Validating ABAP syntax for all changed files..."
          # This would be replaced with actual ABAP syntax validation tool
          find ./src -name "*.abap" -type f -exec echo "Validating {}" \;
          
          # Sample validation script for demonstration purposes
          cat > validate_abap.sh << 'EOF'
          #!/bin/bash
          for file in $(find ./src -name "*.abap" -type f); do
            if grep -q "CALL FUNCTION" "$file" && ! grep -q "EXCEPTIONS" "$file"; then
              echo "Error: $file contains CALL FUNCTION without exception handling"
              exit 1
            fi
          done
          EOF
          chmod +x validate_abap.sh
          ./validate_abap.sh
      
      - name: Validate SAP configuration
        run: |
          echo "Validating SAP configuration files..."
          if [ -f "./config/transport-config.json" ]; then
            jq empty ./config/transport-config.json || (echo "Invalid transport config JSON" && exit 1)
          else
            echo "Warning: transport-config.json not found"
          fi

  # Security scan job for ABAP code
  security-scan:
    name: Security Scan
    needs: validate
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      
      - name: Install security scanning tools
        run: |
          pip install abap-security-scanner==1.2.0
          pip install owasp-dependency-check==0.5.0
      
      - name: Run ABAP security scan
        run: |
          echo "Running ABAP security scan..."
          
          # Create a sample security rule file
          cat > abap_security_rules.json << 'EOF'
          {
            "rules": [
              {
                "id": "ABAP-SQL-INJECTION",
                "description": "Detects potential SQL injection vulnerabilities",
                "severity": "CRITICAL",
                "pattern": "SELECT.*WHERE.*'[^']*\\$[^']*'"
              },
              {
                "id": "ABAP-AUTH-CHECK-MISSING",
                "description": "Missing authority check",
                "severity": "HIGH",
                "pattern": "MODIFY.*(?!AUTHORITY-CHECK)"
              },
              {
                "id": "ABAP-HARDCODED-CREDENTIALS",
                "description": "Detects hardcoded credentials",
                "severity": "CRITICAL",
                "pattern": "(PASSWORD|CREDENTIALS|API_KEY).*=.*'[^']{5,}'"
              }
            ]
          }
          EOF
          
          # For demonstration purposes, run a simple grep-based scan
          ISSUES_FOUND=0
          for rule in $(jq -c '.rules[]' abap_security_rules.json); do
            RULE_ID=$(echo $rule | jq -r '.id')
            PATTERN=$(echo $rule | jq -r '.pattern')
            SEVERITY=$(echo $rule | jq -r '.severity')
            echo "Checking rule $RULE_ID ($SEVERITY)..."
            
            FINDINGS=$(grep -r -E "$PATTERN" --include="*.abap" ./src || true)
            if [ ! -z "$FINDINGS" ]; then
              echo "::error::Security issue found: $RULE_ID"
              echo "$FINDINGS"
              ISSUES_FOUND=1
            fi
          done
          
          # Upload scan results to Security tab using SARIF
          echo '{
            "$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
            "version": "2.1.0",
            "runs": [
              {
                "tool": {
                  "driver": {
                    "name": "ABAP Security Scanner",
                    "rules": []
                  }
                },
                "results": []
              }
            ]
          }' > abap-scan-results.sarif
          
          # Exit with error code if issues were found
          if [ $ISSUES_FOUND -eq 1 ]; then
            echo "Security issues found in code. See log for details."
            # In a real workflow, you might want to fail the build
            # exit 1
          fi
      
      - name: Upload SARIF file
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: abap-scan-results.sarif
          category: abap-custom-scan
      
      - name: Custom SAP Vulnerability Scan
        if: success() || failure()  # Run even if previous step failed
        run: |
          echo "Running SAP-specific vulnerability scan..."
          
          # In a real workflow, this would be a call to a SAP-specific security scanner
          # For demonstration, we'll just check for some common SAP issues
          
          echo "Checking for common SAP security issues:"
          echo "1. Missing authority checks"
          echo "2. Inappropriate RFC destinations"
          echo "3. Insecure table access"
          echo "4. Missing input validation"

  # Testing job for ABAP code
  test:
    name: Run Unit Tests
    needs: [validate, security-scan]
    runs-on: ubuntu-latest
    if: ${{ !fromJSON(github.event.inputs.skip_tests || 'false') }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Set up SAP NW RFC SDK
        run: |
          echo "Setting up SAP NetWeaver RFC SDK..."
          mkdir -p /tmp/nwrfcsdk
          # In a real workflow, download and install the NW RFC SDK
          echo "Simulating installation of SAP NW RFC SDK"
          
          # Create mock structure
          mkdir -p /tmp/nwrfcsdk/lib
          touch /tmp/nwrfcsdk/lib/libsapnwrfc.so
          touch /tmp/nwrfcsdk/lib/libsapucum.so
          
          export SAPNWRFC_HOME=/tmp/nwrfcsdk
      
      - name: Authenticate to Azure
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      
      - name: Get SAP credentials from Key Vault
        uses: azure/get-keyvault-secrets@v1
        with:
          keyvault: ${{ env.AZURE_KEYVAULT_NAME }}
          secrets: 'sap-username, sap-password'
        id: sapSecrets
      
      - name: Run ABAP Unit Tests
        env:
          SAP_USERNAME: ${{ steps.sapSecrets.outputs.sap-username }}
          SAP_PASSWORD: ${{ steps.sapSecrets.outputs.sap-password }}
          SAP_SYSTEM: ${{ needs.validate.outputs.sap_server }}
          SAP_CLIENT: ${{ env.SAP_CLIENT }}
        run: |
          echo "Running ABAP Unit Tests against $SAP_SYSTEM..."
          
          # In a real workflow, this would make an RFC call to execute ABAP unit tests
          # For demonstration, we'll just simulate the result
          
          echo "Simulating connection to SAP system $SAP_SYSTEM with client $SAP_CLIENT"
          echo "Connected as $SAP_USERNAME"
          echo "Running unit tests for package ${{ env.SAP_PACKAGE }}"
          
          # Simulate test execution and results
          echo "Execute: CALL FUNCTION 'REPOSITORY_TEST_RUN'"
          echo "Tests executed: 24"
          echo "Successful: 23"
          echo "Failed: 1"
          
          # For demonstration purposes, we'll collect test results
          cat > test-results.xml << 'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <testsuites>
            <testsuite name="ZCL_GITHUB_DEMO" tests="24" failures="1" errors="0" skipped="0" time="1.42">
              <testcase classname="ZCL_GITHUB_DEMO" name="TEST_FEATURE_1" time="0.15"></testcase>
              <testcase classname="ZCL_GITHUB_DEMO" name="TEST_FEATURE_2" time="0.08">
                <failure message="Expected result not achieved">Error in method CALCULATE_RESULT. Expected 42, got 41.</failure>
              </testcase>
              <!-- More test cases would be here -->
            </testsuite>
          </testsuites>
          EOF
      
      - name: Publish Test Results
        uses: EnricoMi/publish-unit-test-result-action@v2
        if: always()
        with:
          files: test-results.xml
      
      - name: Process Test Results
        run: |
          # In a real workflow, analyze the actual test results
          if grep -q "<failure" test-results.xml; then
            echo "::warning::Some tests failed. Review test results."
            # Decide whether to fail the workflow or continue
            # exit 1
          fi

  # Create transport request job
  create-transport:
    name: Create Transport Request
    needs: [validate, test]
    runs-on: ubuntu-latest
    # Skip if we're using an existing transport request
    if: ${{ github.event.inputs.transport_request == '' }}
    outputs:
      transport_id: ${{ steps.create-tr.outputs.transport_id }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Authenticate to Azure
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      
      - name: Get SAP credentials from Key Vault
        uses: azure/get-keyvault-secrets@v1
        with:
          keyvault: ${{ env.AZURE_KEYVAULT_NAME }}
          secrets: 'sap-username, sap-password'
        id: sapSecrets
      
      - name: Create Transport Request
        id: create-tr
        env:
          SAP_USERNAME: ${{ steps.sapSecrets.outputs.sap-username }}
          SAP_PASSWORD: ${{ steps.sapSecrets.outputs.sap-password }}
          SAP_SYSTEM: ${{ needs.validate.outputs.sap_server }}
          SAP_CLIENT: ${{ env.SAP_CLIENT }}
        run: |
          echo "Creating SAP Transport Request in system $SAP_SYSTEM..."
          
          # In a real workflow, this would make an RFC call to create a transport request
          # For demonstration, we'll just simulate the result
          
          # Simulate transport request creation
          TRANSPORT_ID="DE1K900123"
          echo "Created Transport Request: $TRANSPORT_ID"
          
          # Log to Sentinel for security monitoring
          if [ ! -z "${{ env.SENTINEL_WORKSPACE_ID }}" ]; then
            TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
            LOG_JSON=$(cat << EOF
            {
              "timestamp": "$TIMESTAMP",
              "event_type": "transport_creation",
              "system": "$SAP_SYSTEM",
              "user": "$SAP_USERNAME",
              "transport_id": "$TRANSPORT_ID",
              "github_repo": "${{ github.repository }}",
              "github_workflow": "${{ github.workflow }}",
              "github_actor": "${{ github.actor }}"
            }
            EOF
            )
            echo "Sending log to Sentinel..."
            echo "$LOG_JSON"
          fi
          
          echo "transport_id=$TRANSPORT_ID" >> $GITHUB_OUTPUT
      
      - name: Save Transport ID as Artifact
        if: steps.create-tr.outputs.transport_id != ''
        run: |
          mkdir -p transport-info
          echo "${{ steps.create-tr.outputs.transport_id }}" > transport-info/transport-id.txt
      
      - name: Upload Transport Info
        uses: actions/upload-artifact@v3
        with:
          name: transport-info
          path: transport-info/
          retention-days: 5

  # Deploy code job
  deploy:
    name: Deploy to SAP System
    needs: [validate, test, create-transport]
    runs-on: ubuntu-latest
    # Only run on main branch or manual trigger
    if: ${{ github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch' }}
    environment:
      name: ${{ needs.validate.outputs.environment }}
      url: ${{ format('https://{0}/sap/bc/gui/sap/its/webgui?OBJECT=TR&TRKORR={1}', needs.validate.outputs.sap_server, coalesce(github.event.inputs.transport_request, needs.create-transport.outputs.transport_id)) }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      
      - name: Install SAP RFC SDK
        run: |
          pip install pyrfc==2.6.0
      
      - name: Authenticate to Azure
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      
      - name: Get SAP credentials from Key Vault
        uses: azure/get-keyvault-secrets@v1
        with:
          keyvault: ${{ env.AZURE_KEYVAULT_NAME }}
          secrets: 'sap-username, sap-password'
        id: sapSecrets
      
      - name: Determine Transport ID
        id: get-transport
        run: |
          if [ ! -z "${{ github.event.inputs.transport_request }}" ]; then
            TRANSPORT_ID="${{ github.event.inputs.transport_request }}"
          else
            TRANSPORT_ID="${{ needs.create-transport.outputs.transport_id }}"
          fi
          echo "transport_id=$TRANSPORT_ID" >> $GITHUB_OUTPUT
          echo "Using Transport ID: $TRANSPORT_ID"
      
      - name: Deploy to SAP
        env:
          SAP_USERNAME: ${{ steps.sapSecrets.outputs.sap-username }}
          SAP_PASSWORD: ${{ steps.sapSecrets.outputs.sap-password }}
          SAP_SYSTEM: ${{ needs.validate.outputs.sap_server }}
          SAP_CLIENT: ${{ env.SAP_CLIENT }}
          TRANSPORT_ID: ${{ steps.get-transport.outputs.transport_id }}
          SAP_PACKAGE: ${{ env.SAP_PACKAGE }}
        run: |
          echo "Deploying code to SAP system $SAP_SYSTEM..."
          
          # In a real workflow, this would make an RFC call to deploy the code
          # For demonstration, we'll just simulate the result
          
          # Create a sample deployment script
          cat > deploy_to_sap.py << 'EOF'
          #!/usr/bin/env python3
          import os
          import time
          import json
          
          # Simulated deployment to SAP
          def deploy_to_sap():
              # Get environment variables
              sap_system = os.environ.get('SAP_SYSTEM')
              sap_client = os.environ.get('SAP_CLIENT')
              transport_id = os.environ.get('TRANSPORT_ID')
              sap_package = os.environ.get('SAP_PACKAGE')
              
              print(f"Connecting to SAP system {sap_system} client {sap_client}...")
              time.sleep(2)  # Simulate connection time
              
              print(f"Deploying code from package {sap_package} to transport {transport_id}...")
              time.sleep(3)  # Simulate deployment time
              
              # Simulate deployment results
              results = {
                  "status": "success",
                  "transport_id": transport_id,
                  "objects_updated": 15,
                  "warnings": 2,
                  "errors": 0
              }
              
              print(json.dumps(results, indent=2))
              return results
          
          # Run deployment
          results = deploy_to_sap()
          
          # Exit with appropriate code
          if results["errors"] > 0:
              exit(1)
          else:
              exit(0)
          EOF
          
          chmod +x deploy_to_sap.py
          ./deploy_to_sap.py
      
      - name: Log Deployment to Sentinel
        if: success()
        run: |
          if [ ! -z "${{ env.SENTINEL_WORKSPACE_ID }}" ]; then
            TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
            LOG_JSON=$(cat << EOF
            {
              "timestamp": "$TIMESTAMP",
              "event_type": "sap_deployment",
              "system": "${{ needs.validate.outputs.sap_server }}",
              "environment": "${{ needs.validate.outputs.environment }}",
              "transport_id": "${{ steps.get-transport.outputs.transport_id }}",
              "github_repo": "${{ github.repository }}",
              "github_workflow": "${{ github.workflow }}",
              "github_actor": "${{ github.actor }}",
              "github_sha": "${{ github.sha }}",
              "status": "success"
            }
            EOF
            )
            echo "Sending deployment log to Sentinel..."
            echo "$LOG_JSON"
          fi
      
      - name: Release Transport (QAS)
        if: needs.validate.outputs.environment == 'QAS' && success()
        run: |
          echo "Releasing transport ${{ steps.get-transport.outputs.transport_id }} to PRD..."
          # In a real workflow, this would make an RFC call to release the transport
          # For demonstration, we'll just simulate the result
          
          echo "Transport released successfully."
          echo "Created change document in SAP Solution Manager."
      
      - name: Update Pull Request
        if: github.event_name == 'pull_request' && success()
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const transport_id = '${{ steps.get-transport.outputs.transport_id }}';
            const environment = '${{ needs.validate.outputs.environment }}';
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `âœ… Deployment successful!\n\nEnvironment: ${environment}\nTransport Request: ${transport_id}\n\nThe changes have been successfully deployed to the SAP system.`
            });

  # Notify results job
  notify:
    name: Send Notifications
    needs: [validate, test, deploy]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: Check workflow status
        id: status
        run: |
          if [ "${{ needs.deploy.result }}" == "success" ]; then
            echo "deploy_status=success" >> $GITHUB_OUTPUT
            echo "message=Deployment completed successfully" >> $GITHUB_OUTPUT
          elif [ "${{ needs.deploy.result }}" == "skipped" ]; then
            if [ "${{ needs.test.result }}" == "success" ]; then
              echo "deploy_status=skipped" >> $GITHUB_OUTPUT
              echo "message=Tests passed, deployment skipped" >> $GITHUB_OUTPUT
            else
              echo "deploy_status=failed" >> $GITHUB_OUTPUT
              echo "message=Tests failed, deployment skipped" >> $GITHUB_OUTPUT
            fi
          else
            echo "deploy_status=failed" >> $GITHUB_OUTPUT
            echo "message=Deployment failed" >> $GITHUB_OUTPUT
          fi
      
      - name: Send Teams notification
        if: always()
        uses: aliencube/microsoft-teams-actions@v0.8.0
        with:
          webhook_uri: ${{ secrets.MS_TEAMS_WEBHOOK_URI }}
          title: "SAP-GitHub Integration Workflow"
          summary: "Workflow run status"
          text: |
            **Repository:** ${{ github.repository }}
            **Workflow:** ${{ github.workflow }}
            **Status:** ${{ steps.status.outputs.deploy_status }}
            **Environment:** ${{ needs.validate.outputs.environment }}
            **Message:** ${{ steps.status.outputs.message }}
            
            [View workflow run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
      
      - name: Send email notification for production deployments
        if: needs.validate.outputs.environment == 'PRD'
        run: |
          echo "Sending email notification for production deployment..."
          # In a real workflow, this would send an email to stakeholders
          # For demonstration, we'll just simulate the result
          
          echo "Email sent to stakeholders." 